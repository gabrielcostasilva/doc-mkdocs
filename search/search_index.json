{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#code-annotation-examples","title":"Code Annotation Examples","text":"<p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"examples/#codeblocks","title":"Codeblocks","text":"<p>Some <code>code</code> goes here.</p>"},{"location":"examples/#plain-codeblock","title":"Plain codeblock","text":"<p>A plain codeblock: </p> A simple java class<pre><code>public class MyClass {\npublic static void main(String args[]) {\nSystem.out.println(\"Hello World\");\n}\n}\n</code></pre>"},{"location":"examples/#icons-emojis","title":"Icons &amp; Emojis","text":""},{"location":"GraphQL/","title":"Folder Overview","text":"<p>This repo groups few examples of GraphQL operations implemented with Spring Boot. Checkout each folder to know more about each example.</p>"},{"location":"GraphQL/#overview-of-projects","title":"Overview of Projects","text":"<p>Each folder groups a single example as follows:</p> <ul> <li> <p>query introduces the Spring support for GraphQL queries. Notice this is folder lies in a different repository.</p> </li> <li> <p>mutation shows how to add data to a dataset.</p> </li> <li> <p>subscription extends the mutation code example to use subscription over WebSocket.</p> </li> <li> <p>crud implements a CRUD example with security and integration tests.</p> </li> <li> <p>scalars exemplifies the use of custom scalars with GraphQL and Java.</p> </li> </ul>"},{"location":"GraphQL/crud/","title":"CRUD Example","text":"<p>This project is based on Dan Vega's videos about Spring Boot with GraphQL and testing.</p>"},{"location":"GraphQL/crud/#project-overview","title":"Project Overview","text":"<p>This project presents a complete GraphQL CRUD with Spring Boot for GraphQL. The CRUD consists of a five operations for coffee management. <code>Coffee</code> is a Java record representing a coffee. It has a sequencial id, name and size. The coffee size is implemented as a Java enum, representing possible sizes for a coffee.</p> <p>Management operations are implemented by the <code>CoffeeService</code> class. The <code>CoffeeService</code> is a Spring bean annoted with <code>org.springframework.stereotype.Service</code>. The class set a list of existing coffees, simulating a persistent database. The snippet below shows how the list is set.</p> <pre><code>// ...\nprivate List&lt;Coffee&gt; coffees = new ArrayList&lt;&gt;();\n// ...\n@PostConstruct\nprivate void init() {\ncoffees.add(new Coffee(id.incrementAndGet(), \"Caff\u00e8 Americano\", Size.GRANDE));\ncoffees.add(new Coffee(id.incrementAndGet(), \"Caff\u00e8 Latte\", Size.VENTI));\ncoffees.add(new Coffee(id.incrementAndGet(), \"Caff\u00e8 Caramel Macchiato\", Size.TALL));\n}\n</code></pre> <p>CRUD methods on <code>CoffeeService</code> just manipulate elements in the list. </p> <p><code>CoffeeController</code> uses Spring for GraphQL to set an API for accessing <code>CoffeeService</code> operations. <code>CoffeeController</code> just acts as a wrapper, delegating to <code>CoffeeService</code>. The code snippet below shows two methods.</p> <pre><code>// ...\n@QueryMapping // (1)\npublic Optional&lt;Coffee&gt; findOne(@Argument Integer id) { // (2)\nreturn service.findOne(id); // (3)\n}\n@MutationMapping // (1)\npublic Coffee create(@Argument String name, @Argument Size size) { // (2)\nreturn service.create(name, size); // (3)\n}\n// ...\n</code></pre> <ol> <li>Map the method and the GraphQL schema type. Notice the mapping is automatic as the method has the same name as the schema type.</li> <li>Map the method parameter and the schema type parameter.</li> <li>Delegate behaviour to <code>CoffeeService</code> operations.</li> </ol> <p><code>CoffeeControllerTest</code> tests the five operations in the <code>CoffeeController</code> class. It uses <code>org.springframework.graphql.test.tester.GraphQlTester</code> for testing GraphQL mappings disregarding the transport type used (e.g., HTTP, WebSocket). The class uses the tradicional test slicing technique to load only necessary context for testing GraphQL. In this example, we also had to load the <code>CoffeeService</code> as it has the management operations behaviour. The code snippet below shows the <code>CoffeeControllerTest</code> definition.</p> <pre><code>// ...\n@GraphQlTest(CoffeeController.class) // (1)\n@Import(CoffeeService.class) // (2)\npublic class CoffeeControllerTest {\n@Autowired\nprivate GraphQlTester tester; // (3)\n@Autowired\nprivate CoffeeService service;\n// ...\n</code></pre> <ol> <li>Load only necessary context for GraphQL testing.</li> <li>Load the <code>CoffeeService</code> service class in the context.</li> <li>Inject the object for testing GraphQL types.</li> </ol> <p>Each test consists of three steps:  1. Setting the schema to be tested; 2. Requesting the operation against the schema; 3. Asserting the result.</p> <p>The code snippet below shows the <code>findAll</code> operation.</p> <pre><code>String document = \"\"\"\n    query {\n        findAll {\n            id\n            name\n            size\n        }\n    }\n\"\"\"; // (1)\ntester\n.document(document)\n.execute() // (2)\n.path(\"findAll\")\n.entityList(Coffee.class)\n.hasSize(3); // (3)\n</code></pre> <p>The code snippet below shows the <code>create</code> operation.</p> <pre><code>String document = \"\"\"\n        mutation create($name: String, $size: Size) {\n            create (name: $name, size: $size) {\n                id\n                name\n                size\n            }\n        }\n    \"\"\"; // (1)\nint previousCoffeeCount = service.findAll().size();\ntester\n.document(document)\n.variable(\"name\", \"Caff\u00e8 Latte\")\n.variable(\"size\", Size.GRANDE)\n.execute() // (2)\n.path(\"create\")\n.entity(Coffee.class)\n.satisfies(coffee -&gt; { // (3)\nassertNotNull(coffee.id());\nassertEquals(\"Caff\u00e8 Latte\", coffee.name());\nassertEquals(Size.GRANDE, coffee.size());\n});\nassertEquals(\npreviousCoffeeCount + 1, service.findAll().size()); // (3)\n}\n</code></pre>"},{"location":"GraphQL/crud/#security","title":"Security","text":"<p>Dan Vega published another video extending the previous example by adding security into the project.</p> <p>These are the main changes:</p> <ol> <li>Added dependencies. We need the Spring Security (obviously), but not so obvious, we also need the Web dependency. That is because the original project used WebFlux as base for the project. The WebFlux dependency lacks the <code>Filter</code> interface, necessary for implementing the <code>SecurityFilterChain</code>. Checkout the POM.xml for details.</li> </ol> <pre><code>...\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n...\n</code></pre> <ol> <li> <p>Created <code>SecurityConfig</code> class. This class is responsible for: (i) security settings; (ii) authentication mechanism; and (iii) authorisation rules. The configuration used here does not differ from traditional Spring Security used in Web projects.</p> </li> <li> <p>Added method security into <code>CoffeController</code> class. </p> </li> </ol> <p>Firstly, we secured the <code>findAll()</code> method with role based security. Therefore, only users with the <code>USER</code> role can call the <code>findAll()</code> method.</p> <pre><code>...\n@Secured(\"ROLE_USER\")\n@QueryMapping\npublic List&lt;Coffee&gt; findAll() {\nreturn service.findAll();\n}\n...\n</code></pre> <p>Secondly, we used a newer resource, the <code>PreAuthorize</code> annotation to add expressions-based rules.</p> <pre><code>...\n@PreAuthorize(\"hasRole('ADMIN')\")\n@MutationMapping\npublic Coffee create(@Argument String name, @Argument Size size) {\nreturn service.create(name, size);\n}\n...\n</code></pre>"},{"location":"GraphQL/crud/#run-the-project","title":"Run the project","text":"<p>In order to run the project with annecdotal data, one can use the GraphiQL. Notice the \"i\" in the name. This is a query editor that one can use from the browser. </p> <p>Open your browser on <code>http://localhost:8080/graphiql?path=/graphql</code> to run the following mutation as an example.</p> <p>Notice that we just added security into this project. Therefore, you gonna be asked for credentials. You can use admin as username, and test123 as password.</p> <pre><code>query {\n  findAll {\n    id \n    name\n    size\n  }\n}\n</code></pre>"},{"location":"GraphQL/mutation/","title":"Mutation","text":"<p>This project is based on Josh Long's excellent intro to Spring tips: Spring GraphQL and a previous example.</p> <p>This project extends the previous one by adding a mutation. A mutation is the terminology in GraphQL for adding changes to data.</p>"},{"location":"GraphQL/mutation/#project-overview","title":"Project Overview","text":"<p>Starting from the previous project, we just need to add the <code>mutation</code> operation in our schema, and add the corresponding method in our controller. The code snippet below shows the code added into the existing schema.</p> <pre><code>type Mutation {\n    addCustomer(name: String): Customer\n}\n</code></pre> <p>A <code>Mutation</code> is a type, like <code>Query</code>. In our example, this type has only one operation: <code>addCustomer(String)</code>. This operation returns a <code>Customer</code> type. The type <code>Customer</code> is already defined in our schema.</p> <p>The next step consists of adding the corresponding Java method into our controller, as the snippet below shows.</p> <pre><code>// (...)\nprivate List&lt;Customer&gt; db = new ArrayList&lt;&gt;(){{\nadd(new Customer(1, \"John Doe\"));\nadd(new Customer(2, \"Anna Doe\"));\n}};\n// (...)\n@MutationMapping\npublic Mono&lt;Customer&gt; addCustomer (@Argument String name) {\nvar customer = new Customer(this.db.size() + 1, name);\nthis.db.add(customer);\nreturn Mono.just(customer);\n}\n</code></pre> <p>Notice the first change is necessary because previous code used an immutable list. Next, we just add a method following the conventions set for the schema. In this case, the method receives an argument (<code>String name</code>) and returns a <code>Customer</code>. As we are using WebFlux, the result must be wrapped in a <code>Mono</code> container.</p> <p>As for <code>Query</code>, Spring also provides a shortcut for annotating a mutation: <code>@MutationMapping</code>. The method parameter is also annotated, with <code>@org.springframework.graphql.data.method.annotation.Argument</code>.</p>"},{"location":"GraphQL/mutation/#run-the-project","title":"Run the project","text":"<p>In order to run the project with annecdotal data, one can use the GraphiQL. Notice the \"i\" in the name. This is a query editor that one can use from the browser. </p> <p>Open your browser on <code>http://localhost:8080/graphiql?path=/graphql</code> to run the following mutation as an example.</p> <pre><code>mutation {\n  addCustomer(name: \"Bibiana\") {\n    id, name\n  }\n}\n</code></pre>"},{"location":"GraphQL/query/","title":"Query","text":"<p>This project is based on Josh Long's excellent intro to Spring support for GraphQL.</p> <p>GraphQL is a query language. It enables one to describe and map data from several sources as one single request. It is an alternative to REST-based APIs.</p> <p>Spring support for GraphQL works over HTTP - both Spring MVC and WebFlux - and WebSocket.</p>"},{"location":"GraphQL/query/#project-overview","title":"Project Overview","text":"<p>As of February 2022, there is no stable support in Spring for GraphQL available. Therefore, one we use Spring <code>2.7.0-M1</code>. This project also relies on <code>spring-boot-starter-graphql</code> and <code>spring-boot-starter-webflux</code> dependencies.</p> <p><code>Customer</code> and <code>Order</code> are Java <code>record</code>s that represent data entities whereas <code>GraphQLController</code> handles requests through <code>@Controller</code> annotation. </p> <p>In addition, a schema describing the data structure is necessary. By default, schemas are placed in <code>resources/graphql/</code> folder, with the <code>.graphqls</code> extension. The code below fully shows our schema. It is beyound our goal to explain schema details, but feel free to learn more about it.</p> <p><pre><code>type Query {\n    customers: [Customer]\n    customersByName(name: String): [Customer]\n}\n\ntype Customer {\n    id: ID\n    name: String\n    orders: [Order]\n}\n\ntype Order {\n    id: ID\n    customerId: ID\n}\n</code></pre> Basically, our schema enables one single operation type: querying data. The schema sets two queries. Whereas <code>customer</code> has no argument, <code>customersByName</code> has one <code>String</code> argument. Both queries possibly return a list of <code>Customer</code>. The schema also defines the type <code>Customer</code>. Notice that there are a list of allowed types.</p> <p>Our controller has three methods. The <code>GraphQLController.customers()</code> method returns a list of <code>Customers</code>, as the snippet below shows. The <code>org.springframework.graphql.data.method.annotation.SchemaMapping</code> annotation maps the data schema and its field with the method.</p> <p><pre><code>@SchemaMapping(typeName = \"Query\", field = \"customers\")\npublic Flux&lt;Customer&gt; customers() {\nreturn Flux.fromIterable(db);\n}\n</code></pre> As the method above, the <code>customersByName(String)</code> method maps the method with the second query in the schema. Notice that the <code>customersByName(String)</code> method has an argument, as the schema. Therefore, the need for <code>org.springframework.graphql.data.method.annotation.Argument</code> annotation. </p> <p>Different from the <code>customers()</code> method, <code>customersByName(String)</code> is annotated with <code>org.springframework.graphql.data.method.annotation.QueryMapping</code>. This is  a convinence annotation to use when there is a direct mapping between the schema and the Java method.</p> <pre><code>@QueryMapping\npublic Flux&lt;Customer&gt; customersByName(@Argument String name) {\nreturn Flux.fromIterable(db).filter(item -&gt; item.name().equals(name));\n}\n</code></pre> <p>Finally, the <code>orders(Customer)</code> method returns a list of <code>Order</code>s. Notice that <code>Order</code> is a property of <code>Customer</code>. In this example, it means that <code>Order</code> could be retrieved from a different source. Therefore, the <code>@SchemaMapping</code> annotation maps the type <code>Customer</code>, not <code>Order</code>.</p>"},{"location":"GraphQL/query/#run-the-project","title":"Run the project","text":"<p>In order to run the project with annecdotal data, one can use the GraphiQL. Notice the \"i\" in the name. This is a query editor that one can use from the browser. In order to activate, add <code>spring.graphql.graphiql.enabled=true</code> to the <code>application.properties</code> file. The default URL is <code>/graphiql</code>.</p> <p>Open your browser on <code>http://localhost:8080/graphiql?path=/graphql</code> to run a query.</p>"},{"location":"GraphQL/scalars/","title":"GRAPHQL EXAMPLES - SCALARS","text":"<p>This repo groups few examples of GraphQL operations implemented with Spring Boot.</p> <p>This folder introduces GraphQL custom Scalars. The project in this folder is based on Dan Vega's introduction to custom Scalars in Java.</p> <p>Please, checkout the root repository for a full understanding of GraphQL with Spring Boot.</p>"},{"location":"GraphQL/scalars/#overview","title":"Overview","text":"<p>The project uses the well-known MVC pattern with Spring Boot to build a <code>Product</code> management API with GraphQL. </p> <p>Currently, the <code>ProductController</code> has one single method that lists all <code>Products</code>.</p> <p>The novelty in this project is the use of custom Scalars. Scalars are analogous to data types in programming languages. GraphQL specification defines five native Scalars: String, Boolean, Float, Int, and ID.</p> <p>GraphQL can relate some data types to its native Scalars. For example, Java <code>double</code> is automatically mapped to GraphQL <code>Float</code>. However, programming languages, like Java, go beyond GraphQL five native types. For instance, the code snippet below shows the attribute list of <code>Product</code>. </p> <pre><code>(...)\nprivate Integer id;\nprivate String title;\nprivate boolean isOnSale;\nprivate double weight; private BigDecimal price;\nprivate LocalDateTime dateCreated;\n(...)\n</code></pre> <p>Both <code>BigDecimal</code> and <code>LocalDataTime</code> are data types, but there is no direct mapping for them in GraphQL specification. This is a case for using custom Scalars.</p> <p>Although one can extend the native GraphQL Scalar list by implementing custom Scalars, there are libraries that do exactly this.</p> <p>This project uses Extended Scalars for graphql-java library, which provides implementation for several Java data types.</p> <p>In addition to add the dependency to our <code>pom.xml</code>, we need a custom configuration bean. We also need to declare the custom scalar in our schema.</p> <p>Unfortunately, Extended Scalars library does not provide an implementation for Java <code>LocalDateTime</code>. Therefore, we also bring graphql-java-datetime library into the project. </p> <p>Unlike Extended Scalars, graphql-java-datetime library does not require a configuration bean to work.</p>"},{"location":"GraphQL/scalars/#dependencies","title":"Dependencies","text":"<p>This project adds Extended Scalars for graphql-java library and graphql-java-datetime dependencies.</p>"},{"location":"GraphQL/subscription/","title":"Subscription","text":"<p>This project is based on Josh Long's excellent intro to Spring tips: Spring GraphQL and a previous example.</p> <p>This project extends the previous one by implementing subscription. A subscription is the terminology in GraphQL for receiving data streams.</p>"},{"location":"GraphQL/subscription/#project-overview","title":"Project Overview","text":"<p>As in the previous project, the change starts from the schema, adding an entry for subscription.</p> <pre><code>(...)\n\ntype Subscription {\n    customerEvents (customerId: ID): CustomerEvent\n}\n\ntype CustomerEvent {\n    customer: Customer\n    event: CustomerEventType\n}\n\nenum CustomerEventType {\n    UPDATED\n    DELETED\n}\n\n(...)\n</code></pre> <p>Notice the subscription introduces a new type, <code>CustomerEvent</code>, which is also described in the schema. In turn, <code>CustomerEvent</code> also introduces a new type, <code>CustomerEventType</code>, as an <code>enum</code>.</p> <p>To match the schema, we created a new method in our controller (<code>GraphQLController.customerEvents()</code>), and new also new classes to represent the necessary types (<code>com.example.graphql.CustomerEvent</code> and <code>com.example.graphql.CustomerEventType</code>).</p> <p>As before, the method is annotated to represent the GraphQL subscription (<code>org.springframework.graphql.data.method.annotation.SubscriptionMapping</code>), as the code snippet below shows.</p> <p><pre><code>// (...)\n@SubscriptionMapping\nFlux&lt;CustomerEvent&gt; customerEvents(@Argument Integer customerId) {\nOptional&lt;Customer&gt; customer = db.stream()\n.filter(aCustomer -&gt; aCustomer.id() == customerId)\n.findAny();\nMono&lt;Customer&gt; monoCustomer = Mono.just(customer.get());\nreturn monoCustomer\n.flatMapMany(aCustomer -&gt; {\nvar stream = Stream.generate(() -&gt; new CustomerEvent(aCustomer, Math.random() &gt; .5 ? CustomerEventType.DELETED: CustomerEventType.UPDATED));\nreturn Flux.fromStream(stream);\n})\n.delayElements(Duration.ofSeconds(1))\n.take(10);\n}\n// (...)\n</code></pre> The method body just simulates a continuous stream of <code>CustomerEvent</code>s every second, 10 times. </p> <p>A subscription does not have to be served over HTTP. Therefore, in this example, we use WebSocket. To enable WebSocket, we need to add <code>spring.graphql.websocket.path=/graphql</code> to the <code>application.properties</code> configuration file. </p> <p>That would be all we need. However, there is no simple way to access WebSocket connections. Therefore, a webpage was developed.</p> <p>The webpage uses graphql-ws, a JS library that enables GraphQL over WebSocket, to subscribe and receive data.</p>"},{"location":"GraphQL/subscription/#run-the-project","title":"Run the project","text":"<p>The webpage code access the stream as soon as the page is open. However, the results are sent to JS console. Therefore, one need to open devtools to see the result. </p>"}]}